"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _plugin() {
  const data = require("@parcel/plugin");
  _plugin = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("@parcel/utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = _interopRequireDefault(require("path"));
  _path = function () {
    return data;
  };
  return data;
}
function _nullthrows() {
  const data = _interopRequireDefault(require("nullthrows"));
  _nullthrows = function () {
    return data;
  };
  return data;
}
function _diagnostic() {
  const data = _interopRequireWildcard(require("@parcel/diagnostic"));
  _diagnostic = function () {
    return data;
  };
  return data;
}
function _nodeResolverCore() {
  const data = _interopRequireDefault(require("@parcel/node-resolver-core"));
  _nodeResolverCore = function () {
    return data;
  };
  return data;
}
function _assert() {
  const data = _interopRequireDefault(require("assert"));
  _assert = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function errorToThrowableDiagnostic(error, dependency) {
  return new (_diagnostic().default)({
    diagnostic: {
      message: error,
      codeFrames: dependency.loc ? [{
        codeHighlights: [(0, _diagnostic().convertSourceLocationToHighlight)(dependency.loc)]
      }] : undefined
    }
  });
}
var _default = exports.default = new (_plugin().Resolver)({
  async resolve({
    dependency,
    options,
    specifier,
    pipeline,
    logger
  }) {
    var _dependency$resolveFr, _dependency$meta;
    if (!(0, _utils().isGlob)(specifier)) {
      return;
    }
    let sourceAssetType = (0, _nullthrows().default)(dependency.sourceAssetType);
    let sourceFile = (0, _nullthrows().default)((_dependency$resolveFr = dependency.resolveFrom) !== null && _dependency$resolveFr !== void 0 ? _dependency$resolveFr : dependency.sourcePath);
    let error;
    if (sourceAssetType !== 'js' && sourceAssetType !== 'css') {
      error = `Glob imports are not supported in ${sourceAssetType} files.`;
    } else if (dependency.specifierType === 'url' && !((_dependency$meta = dependency.meta) !== null && _dependency$meta !== void 0 && _dependency$meta.isCSSImport)) {
      error = 'Glob imports are not supported in URL dependencies.';
    }
    if (error) {
      throw errorToThrowableDiagnostic(error, dependency);
    }
    let invalidateOnFileCreate = [];
    let invalidateOnFileChange = new Set();
    switch (specifier[0]) {
      // Path specifier
      case '.':
        {
          specifier = _path().default.resolve(_path().default.dirname(sourceFile), specifier);
          break;
        }

      // Absolute path. Make the glob relative to the project root.
      case '/':
        {
          specifier = _path().default.resolve(options.projectRoot, specifier.slice(1));
          break;
        }

      // Tilde path. Package relative. Resolve relative to nearest node_modules
      // directory, the nearest directory with package.json or the project
      // root - whichever comes first.
      case '~':
        {
          let dir = _path().default.dirname(sourceFile);
          let pkgPath = (0, _nullthrows().default)(options.inputFS.findAncestorFile(['package.json'], dir, options.projectRoot));
          specifier = _path().default.resolve(_path().default.dirname(pkgPath), specifier.slice(2));
          break;
        }

      // Support package-ish specifiers like:
      //   foo      (node_module)
      //   @foo/bar (scoped node_module)
      //
      // First we resolve the initial portion using NodeResolver, then we tack
      // on the remaining glob.
      default:
        {
          // Globs are not paths - so they always use / (see https://github.com/micromatch/micromatch#backslashes)
          let splitOn = specifier.indexOf('/');
          if (specifier[0] === '@') {
            splitOn = specifier.indexOf('/', splitOn + 1);
          }

          // Since we've already asserted earlier that there is a glob present, it shouldn't be
          // possible for there to be only a package here without any other path parts (e.g. `import('pkg')`)
          (0, _assert().default)(splitOn !== -1);
          let pkg = specifier.substring(0, splitOn);
          let rest = specifier.substring(splitOn + 1);

          // This initialisation code is copied from the DefaultResolver
          const resolver = new (_nodeResolverCore().default)({
            fs: options.inputFS,
            projectRoot: options.projectRoot,
            packageManager: options.shouldAutoInstall ? options.packageManager : undefined,
            mode: options.mode,
            logger
          });
          let result;
          try {
            result = await resolver.resolve({
              filename: pkg + '/package.json',
              parent: dependency.resolveFrom,
              specifierType: 'esm',
              env: dependency.env,
              sourcePath: dependency.sourcePath
            });
          } catch (err) {
            if (err instanceof _diagnostic().default) {
              // Return instead of throwing so we can provide invalidations.
              return {
                diagnostics: err.diagnostics,
                invalidateOnFileCreate,
                invalidateOnFileChange: [...invalidateOnFileChange]
              };
            } else {
              throw err;
            }
          }
          if (!result || !result.filePath) {
            throw errorToThrowableDiagnostic(`Unable to resolve ${pkg} from ${sourceFile} when resolving specifier ${specifier}`, dependency);
          }
          specifier = _path().default.resolve(_path().default.dirname(result.filePath), rest);
          if (result.invalidateOnFileChange) {
            for (let f of result.invalidateOnFileChange) {
              invalidateOnFileChange.add(f);
            }
          }
          if (result.invalidateOnFileCreate) {
            invalidateOnFileCreate.push(...result.invalidateOnFileCreate);
          }
        }
    }
    let normalized = (0, _utils().normalizeSeparators)(specifier);
    let files = await (0, _utils().glob)(normalized, options.inputFS, {
      onlyFiles: true
    });
    let dir = _path().default.dirname(sourceFile);
    let results = files.map(file => {
      let relative = (0, _utils().relativePath)(dir, file);
      if (pipeline) {
        relative = `${pipeline}:${relative}`;
      }
      return [file, relative];
    });
    let code = '';
    if (sourceAssetType === 'js') {
      let re = (0, _utils().globToRegex)(normalized, {
        capture: true
      });
      let matches = {};
      for (let [file, relative] of results) {
        let match = file.match(re);
        if (!match) continue;
        let parts = match.slice(1).filter(Boolean).reduce((a, p) => a.concat(p.split('/')), []);
        set(matches, parts, relative);
      }
      let {
        value,
        imports
      } = generate(matches, dependency.priority === 'lazy');
      code = imports + 'module.exports = ' + value;
    } else if (sourceAssetType === 'css') {
      for (let [, relative] of results) {
        code += `@import "${relative}";\n`;
      }
    }
    invalidateOnFileCreate.push({
      glob: normalized
    });
    return {
      filePath: _path().default.join(dir, _path().default.basename(specifier, _path().default.extname(specifier)) + '.' + sourceAssetType),
      code,
      invalidateOnFileCreate,
      invalidateOnFileChange: [...invalidateOnFileChange],
      pipeline: null,
      priority: 'sync'
    };
  }
});
function set(obj, path, value) {
  for (let i = 0; i < path.length - 1; i++) {
    let part = path[i];
    if (obj[part] == null) {
      obj[part] = {};
    }
    obj = obj[part];
  }
  obj[path[path.length - 1]] = value;
}
function generate(matches, isAsync, indent = '', count = 0) {
  if (typeof matches === 'string') {
    if (isAsync) {
      return {
        imports: '',
        value: `() => import(${JSON.stringify(matches)})`,
        count
      };
    }
    let key = `_temp${count++}`;
    return {
      imports: `const ${key} = require(${JSON.stringify(matches)});`,
      value: key,
      count
    };
  }
  let imports = '';
  let res = indent + '{';
  let first = true;
  for (let key in matches) {
    if (!first) {
      res += ',';
    }
    let {
      imports: i,
      value,
      count: c
    } = generate(matches[key], isAsync, indent + '  ', count);
    imports += `${i}\n`;
    count = c;
    res += `\n${indent}  ${JSON.stringify(key)}: ${value}`;
    first = false;
  }
  res += '\n' + indent + '}';
  return {
    imports,
    value: res,
    count
  };
}